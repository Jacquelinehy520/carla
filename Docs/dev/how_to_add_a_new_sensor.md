<h1>How to add a new sensor</h1>

> _This document is a work in progress._

This tutorial explains the basics for adding a new sensor to CARLA. It provides
the necessary steps to implement a sensor in Unreal Engine 4 (UE4) and expose
its data via CARLA's Python API. We'll follow all the steps by creating a new
sensor as an example.

## Prerequisites

In order to implement a new sensor, you'll need to compile CARLA source code,
for detailed instructions on how to achieve this see
[Building from source](../building_from_source.md).

This tutorial also assumes the reader is fluent in C++ programming.

## Introduction

Sensors in CARLA are a special type of actor that produce a stream of data. Some
sensors produce data continuously, every time the sensor is updated, other
produce data only after certain events. For instance, a camera produces an image
on every update, but a collision sensor is only triggered in the event of a
collision.

Although most sensors compute their measurements in the server side (UE4), it's
worth noticing that some sensors run in the client-side only. An example of such
sensor is the GNSS, it computes the simulated geo-location in the client-side
based on its 3D location. For further details see
[Appendix: Client-side sensors](#appendix-client-side-sensors).

In this tutorial, we'll be focusing on server-side sensors.

In order to have a sensor running inside UE4 sending data all the way to a
Python client, we need to cover the whole communication pipeline.

![Communication pipeline](../img/pipeline.png)

Thus we'll need the following classes covering the different steps of the
pipeline

  * **Sensor actor**<br>
    Actor in charge of measuring and/or simulating data. Running in Carla plugin
    using UE4 framework. Accessible by the user as Sensor actor.

  * **Serializer**<br>
    Object containing methods for serializing and deserializing the data
    generated by the sensor. Running in LibCarla, both server and client.

  * **Sensor data**<br>
    Object representing the data generated by the sensor. This is the object
    that will be passed to the final user, both in C++ and Python APIs.

!!! note
    To ensure best performance, sensors are registered and dispatched using a
    sort of "compile-time plugin" system based on template meta-programming.
    Most likely, the code won't compile until all the pieces are present.

## Creating a new sensor

We're going to create a sensor that detects other actors around our vehicle. For
that we'll create a trigger box that detects objects within, and we'll be
reporting status to the client every simulation update. Let's call it _Safe
Distance Sensor_.

![Trigger box](../img/safe_distance_sensor.jpg)

_For the sake of simplicity we're not going to take into account all the edge
cases, nor it will be implemented in the most efficient way. This is just an
illustrative example._

#### 1. The sensor actor

This is the most complicated class we're going to create. Here we're running
inside Unreal Engine framework, knowledge of UE4 API will be very helpful but
not indispensable, we'll assume the reader has never worked with UE4 before.

Inside UE4, we have a similar hierarchy as we have in the client-side, `ASensor`
derives from `AActor`, and an actor is roughly any object that can be dropped
into the world. `AActor` has a virtual function called `Tick` that we can use to
update our sensor on every simulator update. Higher in the hierarchy we have
`UObject`, base class for most of UE4 classes. It is important to know that
objects deriving from `UObject` are handle via pointers and are garbage
collected when they're no longer referenced. Class members pointing to
`UObject`s need to be marked with `UPROPERTY` macros or they'll be garbage
collected.

Let's start.

This class has to be located inside Carla plugin, we'll create two files for our
new C++ class

  * `Unreal/CarlaUE4/Plugins/Carla/Source/Carla/Sensor/SafeDistanceSensor.h`
  * `Unreal/CarlaUE4/Plugins/Carla/Source/Carla/Sensor/SafeDistanceSensor.cpp`

At the very minimum, the sensor is required to inherit `ASensor`, and provide a
static method `GetSensorDefinition`; but we'll be overriding also the `Set`,
`SetOwner`, and `Tick` methods. This sensor also needs a trigger box that will
be detecting other actors around us. With this and some required boiler-plate
UE4 code, the header file looks like

```cpp
#pragma once

#include "Carla/Sensor/Sensor.h"

#include "Carla/Actor/ActorDefinition.h"
#include "Carla/Actor/ActorDescription.h"

#include "Components/BoxComponent.h"

#include "SafeDistanceSensor.generated.h"

UCLASS()
class CARLA_API ASafeDistanceSensor : public ASensor
{
  GENERATED_BODY()

public:

  ASafeDistanceSensor(const FObjectInitializer &ObjectInitializer);

  static FActorDefinition GetSensorDefinition();

  void Set(const FActorDescription &ActorDescription) override;

  void SetOwner(AActor *Owner) override;

  void Tick(float DeltaSeconds) override;

private:

  UPROPERTY()
  UBoxComponent *TriggerBox = nullptr;
};
```

In the cpp file, first we'll need some includes

```cpp
#include "Carla.h"
#include "Carla/Sensor/SafeDistanceSensor.h"

#include "Carla/Actor/ActorBlueprintFunctionLibrary.h"
#include "Carla/Util/BoundingBoxCalculator.h"
```

Then we can proceed to implement the functionality. The constructor will create
the trigger box, and tell UE4 that we want our tick function to be called. If
our sensor were not using the tick function, we can disable it here to avoid
unnecessary ticks

```cpp
ASafeDistanceSensor::ASafeDistanceSensor(const FObjectInitializer &ObjectInitializer)
  : Super(ObjectInitializer)
{
  TriggerBox = CreateDefaultSubobject<UBoxComponent>(TEXT("TriggerBox"));
  TriggerBox->SetupAttachment(RootComponent);
  TriggerBox->SetHiddenInGame(true);
  TriggerBox->SetCollisionProfileName(FName("OverlapAll"));

  PrimaryActorTick.bCanEverTick = true;
}
```

Now we need to tell Carla what attributes this sensor has, this is going to be
used to create a new blueprint in our blueprint library, users can use this
blueprint to configure and spawn this sensor. We're going to define here the
attributes of our trigger box, in this example we'll expose only X and Y
safe distances

```cpp
FActorDefinition ASafeDistanceSensor::GetSensorDefinition()
{
  auto Definition = UActorBlueprintFunctionLibrary::MakeGenericSensorDefinition(
      TEXT("other"),
      TEXT("safe_distance"));

  FActorVariation Front;
  Front.Id = TEXT("safe_distance_front");
  Front.Type = EActorAttributeType::Float;
  Front.RecommendedValues = { TEXT("60.0") };
  Front.bRestrictToRecommended = false;

  FActorVariation Back;
  Back.Id = TEXT("safe_distance_back");
  Back.Type = EActorAttributeType::Float;
  Back.RecommendedValues = { TEXT("40.0") };
  Back.bRestrictToRecommended = false;

  FActorVariation Lateral;
  Lateral.Id = TEXT("safe_distance_lateral");
  Lateral.Type = EActorAttributeType::Float;
  Lateral.RecommendedValues = { TEXT("40.0") };
  Lateral.bRestrictToRecommended = false;

  Definition.Variations.Append({ Front, Back, Lateral });

  return Definition;
}
```

With this, the sensor factory is able to create a _Safe Distance Sensor_ on user
demand. Immediately after the sensor is created, the `Set` function is called
with the parameters that the user requested

```cpp
void ASafeDistanceSensor::Set(const FActorDescription &Description)
{
  Super::Set(Description);

  float Front = UActorBlueprintFunctionLibrary::RetrieveActorAttributeToFloat(
    "safe_distance_front",
    Description.Variations,
    60.0f);
  float Back = UActorBlueprintFunctionLibrary::RetrieveActorAttributeToFloat(
    "safe_distance_back",
    Description.Variations,
    40.0f);
  float Lateral = UActorBlueprintFunctionLibrary::RetrieveActorAttributeToFloat(
    "safe_distance_lateral",
    Description.Variations,
    40.0f);

  constexpr float M_TO_CM = 100.0f; // Unit conversion.

  float LocationX = M_TO_CM * (Front - Back) / 2.0f;
  float ExtentX = M_TO_CM * (Front + Back) / 2.0f;
  float ExtentY = M_TO_CM * Lateral;

  TriggerBox->SetComponentLocation(FVector{LocationX, 0.0f, 0.0f});
  TriggerBox->SetBoxExtent(FVector{ExtentX, ExtentY, 40.0f});
}
```

Note that the set function is called before UE4's `BeginPlay`, we won't use
this virtual function here, but it's important for other sensors.



Another useful notification is `SetOwner(AActor *Owner)`.


- - -

Create a sensor actor deriving from `ASensor` (or one of its derived classes),
this class requires to implement the following methods:

  - `static FActorDefinition GetSensorDefinition();` Returns an actor definition
    that will be given to the user in the client-side to configure the details
    of the sensor.
  - `void Set(const FActorDescription &ActorDescription) override;` Configure
    the sensor with the attributes that the user requested.
  - `void Tick(float DeltaTime) override;` This function is called on every game
    update and here the sensor is expected to produce the data and send it (more
    on this below).
  - Also requires the UE4 macros, `UCLASS()` and `GENERATED_BODY()`.

This class should be added to
`Unreal/CarlaUE4/Plugins/Carla/Source/Carla/Sensor` folder.

The class declaration should look similar to this

```cpp
#pragma once

#include "Carla/Sensor/Sensor.h"

#include "Carla/Actor/ActorDefinition.h"
#include "Carla/Actor/ActorDescription.h"

#include "MySensor.generated.h"

UCLASS()
class CARLA_API AMySensor : public ASensor
{
  GENERATED_BODY()

public:

  static FActorDefinition GetSensorDefinition();

  void Set(const FActorDescription &ActorDescription) override;

  void Tick(float DeltaSeconds) override;
};
```

and the .cpp something like

```cpp
#include "Carla.h"
#include "Carla/Sensor/MySensor.h"

#include "Carla/Actor/ActorBlueprintFunctionLibrary.h"

#include "StaticMeshResources.h"

FActorDefinition AMySensor::GetSensorDefinition()
{
  auto Def = UActorBlueprintFunctionLibrary::MakeGenericSensorDefinition(
      TEXT("other"),
      TEXT("my_sensor"));
  // Add custom attributes to Def here if necessary.
  return Def;
}

AMySensor::AMySensor(const FObjectInitializer &ObjectInitializer)
  : Super(ObjectInitializer)
{
  PrimaryActorTick.bCanEverTick = true; // False if Tick is not necessary.

  auto MeshComp = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("RootComponent"));
  MeshComp->SetCollisionProfileName(UCollisionProfile::NoCollision_ProfileName);
  MeshComp->bHiddenInGame = true;
  MeshComp->CastShadow = false;
  MeshComp->PostPhysicsComponentTick.bCanEverTick = false;
  RootComponent = MeshComp;
}

AMySensor::Set(const FActorDescription &ActorDescription)
{
  Super::Set(ActorDescription);
  // Retrive custom attributes here if necessary.
}

AMySensor::Tick(float DeltaSeconds)
{
  Super::Tick(DeltaSeconds);

  auto CustomData = ... // Do the measurement.

  GetDataStream().Send_GameThread(*this, CustomData);
}
```

`ASensor` contains a `FDataStream` for sending the data through the streaming
server. Sensor actors should write their measurements to this stream using one
of the two methods in the stream, `Send_Async` or `Send_GameThread` depending in
which thread they're producing the data. The class `FDataStream` is quite well
documented, take a look for more details.

The stream methods won't compile however until the sensor and its serializer are
registered, this takes us to the next class required.

#### 2. Sensor Serializer

This class is in charge of serializing and deserializing the data. The only
requirement of this class is providing two static methods with the following
signatures:

  - `static Buffer Serialize(const YourASensor &sensor, ...data here...);` This
    function should convert the data provided by the sensor actor into a
    `Buffer` object. The signature is quite open.
  - `static SharedPtr<SensorData> Deserialize(RawData data);` This function has
    to convert a `RawData` object (which is a wrapper around a buffer with some
    extra meta-information) into a `SensorData` derived class.

Serialization happens in the simulator-side, right after writing the data to the
stream. Deserialization happens in the client-side, right after delivering the
data to the user in the callback function provided to the `listen` method of the
sensors.

This class should be added to `LibCarla/source/carla/sensor/s11n` folder, and
its corresponding namespace.

There are already some `SensorData` classes implemented, like images and arrays,
otherwise you must add a new class fitting your needs. In this case the class
must also be exposed to Python. I will add more info on this in the tutorial.

#### 3. Register your classes

Your classes must be registered within the `SensorRegistry` as an
`std::pair<Sensor *, Serializer>`. Also follow the steps in the header as the
includes must be added in the right places.

```cpp
// LibCarla/source/carla/sensor/SensorRegistry.h

using SensorRegistry = CompositeSerializer<
  std::pair<ASceneCaptureCamera *, s11n::ImageSerializer>,
  std::pair<ADepthCamera *, s11n::ImageSerializer>,
  std::pair<ASemanticSegmentationCamera *, s11n::ImageSerializer>,
  std::pair<ARayCastLidar *, s11n::LidarSerializer>
>;
```

And that's it, the sensor registry now do its compile-time magic to dispatch the
right data to the right serializer.

## Appendix: Reusing buffers

## Appendix: Client-side sensors
